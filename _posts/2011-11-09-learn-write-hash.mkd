--- 
type: post
status: publish
tags: 
- hash

title: 学写hash
category: study

layout: post
meta: 
  _edit_last: "1"
published: true
---
相信看这篇文章的人都学过Hash，但是学归学过，第一个hash函数就是不知道应该如何开始。所以了，这里不讨论书本上讲的内容，不讲理论，就是要告诉大家如何设计第一个Hash函数，当然大神们飘过^_^

我觉得那些关于数字方面的hash还是蛮简单的，只要明白字符串的hash怎么做了，其它的应该都会了。很简单的思考一下字符串hash，大不了我们把每个byte或者每几个byte相加呗，貌似是一个不错的想法。但是我们看一下这个样一个字符串”abcdef”和”fedcba”。你可以发现，这两个字符串是相互颠倒的，明显不应该是同一个字符串，按照上面的方法计算的值确实一样的。

Ok，再来看几种情况，”abcdef”和”acbdfe”， ”abcdef”和”aaceef”，他们按照上面的方法计算的值依然是一样的。总结一下这几种情况，一是存在的字符一样，只是位置不一致；二是它们在某些字符上面加上和减去相同值导致。我们肉眼看到的不同字符串，结果计算的hash值是一样的。之所以是这样，是因为我们看到的字符串中的字符是有位置顺序的，因此我们必须把这个因素考虑进去。因此，我们可以利用其他进制转化十进制时，所谓的按权位展开，把位置因素加进去。
我们看一下有名的times33算法，它是一个字符串hash。<!--split-->
{%highlight c linenos%}
int times33(char *str)
{
	int ret = 0;

	while(*str) {
	    ret = ret &lt;&lt; 5 + ret + *str;
      }

      return ret;
}
{%endhighlight%}
是不是很简单。解释一下”ret = ret &lt;&lt; 5 + ret + *str;”这句话，其实就是ret*33 + *str 的意思，左移5位，相当于乘以32，这样做的目的是充分利用硬件的计算速度。最后的结果就是字符串不断的按权位展开。至于为什么是乘以33，我也说不清楚，这个是统计结果也好，证明结论也罢，它的结果是让hash值分布的很均匀，我们暂时当成经验就好了。

好啦，看来hash没什么难的。我们再看一个实际的例子，比如有一个汉语词库，我每次需要检查这个某个词是否在这个词库里面。马上计上心头----hash。我们检查是否存在这个词就是一个查找过程嘛。Hash可以加快查找速度，不错，可以试试。简单点，假设我们所有词的第一个字都是不一样的。因此，我们需要对第一个字hash。如何设计了？我们分析utf8格式的汉字，为三个字节，是从unicode字符集编码过来，而unicode编码是连续的。所以，我们的只需要把三字节的utf8汉字反推为unicode编码就够了。呐，代码自己发挥，当然，里面还有很多的陷阱。

差不多了，但是我还想扩充一下。如果你的hash桶需要很大怎么办，在内存里面肯定是不能放完的，你可以考虑分层hash。还有在我们分布式系统里面长用到的东西----一致hash，可以很好的解决负载均衡和线性扩容的问题。
