--- 
type: post
status: publish
tags: 
- x86
- 保护模式

title: x86实模式和保护模式的相互切换问题

layout: post
meta: 
  _edit_last: "1"
published: true
---
在《自己动手写操作系统》中有几段代码是关于保护模和实模式相互切换的
;准备被切换到保护模式
{%highlight asm%}
mov  eax, cr0
or   eax, 1
mov  cr0, eax</pre>
;真正进入保护模式
jmp  dword SelectorCode32:0
{%endhighlight%}

对于这几句话，有两处疑惑。首先是jmp  dword SelectorCode32:0为什么能够执行，再就是如何被执行的。<!--split-->

在执行了mov cr0, eax之后，cpu就已经处于保护模式了，那么按照保护模式的取指令方式，下一条被寻址到指令就应该不是jmp  dword SelectorCode32:0。然而事实是执行了jmp这句话。导致这个结果的原因是“指令预取队列”。看下面80486的架构图：

<a href="http://img.yalog.info/uploads/20120505/arch.svg.png"><img class="alignnone size-medium wp-image-63" title="800px-80486DX2_arch.svg" src="http://img.yalog.info/uploads/20120505/arch.svg_thumb.png" alt="" width="300" height="217" /></a>详细的介绍可以看百度百科<a title="80486" href="http://baike.baidu.com/view/410861.htm" target="_blank">80486</a>

早在执行mov cr0, eax之前，指令预取部件就把紧接着的好几条指令，从cache或者是内存放入到指令预取队列了。而指令译码部件总是从指令预取队列中读取有效的指令。所以cpu执行的指令并不是直接从内存中获取的。我们正是利用了cpu对指令的缓冲特性才实现了对jmp  dword SelectorCode32:0执行。那么为什么会设置这个功能了，其实就是为了在总线空闲的时候，读取指令，提高系统的并行度。

当我们执行了mov cr0, eax之后，cpu就会采用保护模式的寻址方法继续往指令队列和cache中读指令，做缓冲。但是这些缓冲里面的实模式代码是我们不想执行的。因此就必须想办法把这些指令清楚掉，所以就用到了jmp指令。cpu遇到指令跳转接着就会把指令队列清空。但是我还觉得，如果没有jmp，cs里面的选择子是不合法的，应该需要一个合法的选择子来更新cs。至于执行jmp时什么没有因为指令的预取出现保护性异常，我觉得是这与x86指令流水方式有关，应该说它在这里设计的很巧妙。

在执行jmp指令时，已经进入了保护模式。因此这里执行一个长跳转，cpu就要进行特权级的检查。按照代码段跳转的特权级检查规则，对于一致代码段，必须是cpl或者rpl&gt;dpl。对于非一致代码段就必须是同一特权级的代码间跳转。因此这里对于跳转到内核，只需原cs里面的伪选择子cpl=0就够了，因此可以得出结论设置保护模式的这段代码必须加载到，cs=xxxxxxxxxxxxx000b的段基址上面。ps：这个暂时还没有验证
